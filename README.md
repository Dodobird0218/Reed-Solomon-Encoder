# Reed-Solomon編碼器

## 1. 專案概述

本專案實現了一個用 Go 語言編寫的 Reed-Solomon 錯誤更正碼編碼器。Reed-Solomon碼是一種前向錯誤更正（FEC）碼，廣泛用於數位存儲和通信系統中，以檢測和更正數據傳輸或存儲過程中的錯誤。

編碼器接受一個消息並生成冗餘的奇偶校驗數據，這些數據可以用來恢復原始消息，即使其中的部分數據受到損壞（在一定限度內）。此實現使用系統性編碼方法，意味著原始數據作為編碼輸出的第一部分被保留。

主要特點：
- 實現了 Galois Field GF(2^8) 算術運算
- 支持可配置的數據分片和奇偶校驗分片
- 支持 JSON 輸入/輸出
- 系統性編碼（保留原始數據）

## 2. 數學背景

### Galois Field 理論

Reed-Solomon 編碼在 Galois Field（有限域）上運作。此實現使用 GF(2^8)，其特點如下：
- 包含 256 個元素（0 到 255）
- 使用多項式算術模一個不可約多項式
- 所有運算（加法、減法、乘法、除法）都在該域內封閉

### Reed-Solomon 編碼理論

Reed-Solomon 碼基於有限域上的多項式插值：
- 數據被視為多項式的係數
- 編碼涉及在特定點評估該多項式
- 編碼消息由原始數據和多項式評估組成
- 錯誤更正能力取決於冗餘（奇偶校驗）符號的數量
- 擁有 `n` 個奇偶校驗符號時，可以更正最多 `n/2` 個錯誤

### 拉格朗日插值

編碼器使用 Lagrange interpolation 來計算奇偶校驗分片：
- 創建一個通過給定數據點的多項式
- 在不同點評估該多項式以生成奇偶校驗數據
- 此方法確保了編碼的系統性特性（保留原始數據）

## 3. 實現細節

### GF(2^8) 實現

- 預計算指數和對數表以提高域運算的效率
- 實現的域運算：
  - 加法（XOR 操作）
  - 減法（在 GF(2^8) 中與加法相同）
  - 乘法（使用對數表）
  - 除法（使用對數表）
  - 幂和逆運算

### Reed-Solomon 編碼器

實現了兩種編碼方法：
1. **Lagrange Interpolation Method**：
   - 構建一個通過數據點的多項式
   - 在特定點評估該多項式以生成奇偶校驗分片

2. **Efficient Encoding Method**：
   - 使用 Horner's method 進行多項式評估
   - 對於較大數據集更具計算效率

### 文件 I/O 處理

- 使用 JSON 格式進行輸入/輸出
- 支持從 JSON 文件中讀取消息
- 支持將編碼數據寫入 JSON 文件，並包含原始消息

## 4. 使用說明

### 前置條件

- Go 編程語言（建議使用 1.16 或更高版本）
- 不需要外部依賴

### 構建專案

```bash
# 克隆倉庫
git clone [repository-url]
cd rs-encoder

# 構建專案
go build -o rs-encoder cmd/main.go
```

### 運行編碼器

```bash
# 基本用法
./rs-encoder <input-file> <output-file>

# 示例
./rs-encoder data/message.json data/encoded.json
```

### 輸入格式

輸入的 JSON 文件應具有以下格式：
```json
{
  "message": [
    "0x00", "0x01", "0x02", "0x03", "0x04", "0x05"
  ]
}
```

### 輸出格式

輸出的 JSON 文件將具有以下格式：
```json
{
  "message": [
    "0x00", "0x01", "0x02", "0x03", "0x04", "0x05"
  ],
  "encoded": [
    "0x00", "0x01", "0x02", "0x03", "0x04", "0x05",
    "0xXX", "0xXX", "0xXX", "0xXX", "0xXX", "0xXX",
    "0xXX", "0xXX", "0xXX", "0xXX", "0xXX", "0xXX"
  ]
}
```

其中 `encoded` 中的前 6 個值是原始消息，最後 12 個值是奇偶校驗數據。

### 配置

可以修改 `main.go` 中的常量來更改：
- 在有限域中使用的原始多項式
- 數據分片的數量
- 奇偶校驗分片的數量 