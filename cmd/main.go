package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"rs-encoder/gf"
	"rs-encoder/rs"
	"strings"
)

// MessageData structure for parsing message.json
type MessageData struct {
	Message []string `json:"message"`
}

// EncodedData structure for generating encoded.json
type EncodedData struct {
	Message []string `json:"message"`
	Encoded []string `json:"encoded"`
}

func main() {
	// Initialize finite field GF(2^8)
	field := gf.NewGF(0x1D) // Use GF(2^8) finite field, simplified polynomial x^4 + x^3 + x^2 + 1

	// Read input from message.json
	messageData, err := readMessageFromJSON("data/message.json")
	if err != nil {
		fmt.Printf("Unable to read input file: %v\n", err)
		return
	}

	// Convert hexadecimal strings to byte array
	message := hexStringsToBytes(messageData.Message)
	dataShards := len(message)
	parityShards := 12 // Total of 18 shards, minus 6 data shards

	// Create a new Reed-Solomon encoder (using consecutive integers as evaluation points)
	encoder := rs.NewRSEncoder2(field, dataShards, parityShards)

	// Encode using Lagrange interpolation method
	encodedData := encoder.Encode(message)

	// Print original message
	fmt.Println("Original message (message shards):")
	printArray(message)

	// Print encoding result
	fmt.Println("\nEncoding result generated by interpolation (codeword shards):")
	printArray(encodedData)

	// Create output JSON structure
	outputData := EncodedData{
		Message: messageData.Message,
		Encoded: bytesToHexStrings(encodedData),
	}

	// Save to output file
	err = saveToJSON("encoded.json", outputData)
	if err != nil {
		fmt.Printf("Unable to save output file: %v\n", err)
		return
	}

	fmt.Println("\nEncoding result has been saved to encoded.json")
}

// Read message.json file
func readMessageFromJSON(filename string) (MessageData, error) {
	var data MessageData
	fileContent, err := ioutil.ReadFile(filename)
	if err != nil {
		return data, err
	}

	err = json.Unmarshal(fileContent, &data)
	return data, err
}

// Save results to JSON file
func saveToJSON(filename string, data EncodedData) error {
	jsonData, err := json.MarshalIndent(data, "", "  ")
	if err != nil {
		return err
	}

	return ioutil.WriteFile(filename, jsonData, 0644)
}

// Convert hexadecimal string array to byte array
func hexStringsToBytes(hexStrings []string) []byte {
	bytes := make([]byte, len(hexStrings))
	for i, hexStr := range hexStrings {
		// Remove "0x" prefix
		cleanHex := strings.TrimPrefix(hexStr, "0x")

		// Parse hexadecimal string
		var value byte
		fmt.Sscanf(cleanHex, "%x", &value)
		bytes[i] = value
	}
	return bytes
}

// Convert byte array to hexadecimal string array
func bytesToHexStrings(bytes []byte) []string {
	hexStrings := make([]string, len(bytes))
	for i, b := range bytes {
		hexStrings[i] = fmt.Sprintf("0x%02x", b)
	}
	return hexStrings
}

// Print array
func printArray(array []byte) {
	fmt.Print("[ ")
	for i, val := range array {
		if i > 0 {
			fmt.Print(" ")
		}
		fmt.Print(val)
	}
	fmt.Println(" ]")

	// Print hexadecimal format
	fmt.Print("Hexadecimal: [ ")
	for i, val := range array {
		if i > 0 {
			fmt.Print(" ")
		}
		fmt.Printf("0x%02x", val)
	}
	fmt.Println(" ]")
}
